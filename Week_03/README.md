### 如何理解“递归”
递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。

### 递归需要满足的三个条件
同时满足以下三个条件，就可以用递归来解决

1. 一个问题的解可以分解为几个子问题的解
何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。

3. 存在递归终止条件
把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。
还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。

### 如何编写递归代码？
写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。

### 写递归代码的关键
+ 找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码
+ 只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤

### 递归重点技巧(自己的理解)
1. 重点是要将问题化成递归树，想清楚每一层的节点是怎么样的，只有思考清楚逻辑才能翻译成代码，并进行剪枝。
+ 比如全排列的问题，可以选N个数值，相当于N叉树；
+ 但另外的角度，如果每个数字都是选或者不选，那就是2叉树
2. 要注意递归后的操作可能需要恢复现场，特别是使用全局的数据结构进行相关操作时
3. 在递归方法里面，重新调用递归几次，代表本层有几个兄弟节点
+ 比如二叉树的遍历，通常是左右子树的遍历，所以会调用两次方法
4. 有些复杂的场景下要找到递归的模型，并进行简化，比如Lc 25，K个数为一组反转链表，这里就将K个数抽象成一个递归，即一组一个递归，那题目就变成了普通的递归遍历了
```
public void recur(int level, int param) {
    // do something
    left = recur();
    right = recur();
    // do something
}
```
+ 如果是N叉树，同理应该也是调用N次，通常使用循环N次编写代码
```
public void recur(int level, int param) {
    for (int i = 0; i < n; i++) {
        // do something
        recur();
        // do something
   }
}
```

### 递归JAVA模板
```$xslt
public void recur(int level, int param) {
    // terminator
    if (level > MAX_LEVEL) {
        // process result
        return;
    }
    
    // process current logic
    process(level, param);
   
     // drill down
     // 在这里调用几次递归，相当于本层有几个兄弟节点，这个很重要
    recur( level: level + 1, newParam);
    
    // restore current status
}
```

### 要点
1. 不要人肉进行递归（最大误区）
2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
3. 数学归纳法思维

### 警惕堆栈溢出
可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。

### 警惕重复计算
利用缓存避免重复计算。可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

### 怎么将递归代码改写为非递归代码？
例子1：
递推公式  f(x) =f(x-1)+1
```$xslt
int f(int n) {
  int ret = 1;
  for (int i = 2; i <= n; ++i) {
    ret = ret + 1;
  }
  return ret;
}
```

例子2：
递推公式  f(n) = f(n - 1) + f (n - 2)
```$xslt
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

### 递归改为迭代循环的非递归写法
##### 笼统地讲，所有递归都是可以改写的。
+ 因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。
+ 如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。
+ 但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，徒增了实现的复杂度。

---
### 分治
分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

#### 分治算法是一种处理问题的思想，递归是一种编程技巧
分治算法的递归实现中，每一层递归都会涉及这样三个操作：
+ 分解：将原问题分解成一系列子问题；
+ 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
+ 合并：将子问题的结果合并成原问题。

#### 分治算法能解决的问题，一般需要满足下面这几个条件：
+ 原问题与分解成的小问题具有相同的模式；
+ 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；
+ 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
+ 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

代码模板
```$xslt
private static int divide_conquer(Problem problem, ) {
  
  if (problem == NULL) {
    int res = process_last_result();
    return res;     
  }
  subProblems = split_problem(problem)
  
  res0 = divide_conquer(subProblems[0])
  res1 = divide_conquer(subProblems[1])
  
  result = process_result(res0, res1);
  
  return result;
}
```
---
### 回溯

#### 如何理解“回溯算法”？
2004 年上映了一部非常著名的电影《蝴蝶效应》，讲的就是主人公为了达到自己的目标，一直通过回溯的方法，回到童年，在关键的岔路口，重新做选择。当然，这只是科幻电影，我们的人生是无法倒退的，但是这其中蕴含的思想其实就是回溯算法。

笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。